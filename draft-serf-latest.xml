<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.36 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>

<rfc ipr="trust200902" docName="draft-serf-latest" category="std">

  <front>
    <title abbrev="SERF">Secruity Event Refinement Framework</title>

    <author initials="R." surname="Moskowitz" fullname="Robert Moskowitz">
      <organization abbrev="Huawei">Huawei</organization>
      <address>
        <postal>
          <street></street>
          <city>Oak Park</city>
          <region>MI</region>
          <code>48237</code>
          <country>USA</country>
        </postal>
        <email>rgm@htt-consult.com</email>
      </address>
    </author>
    <author initials="H." surname="Birkholz" fullname="Henk Birkholz">
      <organization abbrev="Fraunhofer SIT">Fraunhofer SIT</organization>
      <address>
        <postal>
          <street>Rheinstrasse 75</street>
          <city>Darmstadt</city>
          <code>64295</code>
          <country>Germany</country>
        </postal>
        <email>henk.birkholz@sit.fraunhofer.de</email>
      </address>
    </author>

    <date year="2017" month="February" day="08"/>

    <area>Security</area>
    <workgroup>TBD</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>Millions of low-level events, such as byte counters, triggered filter policies, or interaction attempts, are created continuously in a multitude of network topologies. Constrained-node networks, such as sensor networks, smart meters in LPWAN, or vehicle networks with various interconnected layer 2 topologies, exhibit domain-specific behaviors that can be considered to be compliant or - in contrast - as potential anomalies in regard to declarative guidance. In order to facilitate an automated assessment of the behavior of interconnected components that constitute, for example, service chains or downstream work-flows, available low-level events have to be brought into a larger semantic context by refining them into a lower volume of security events with a higher grade of expressiveness or significance. This work describes an architecture, its corresponding components, interfaces and interaction model, as well as a security event information model to facilitate  a refinement framework to process event streams via aggregation, correlation and machine-learning methods.  The components defined are virtual encapsulations of corresponding machine-learning and AI function that require certain features derived from the event data that is made available by low-level event streams.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>Security automation requires input of high refinement and high confidence to base corresponding security decisions on. Vital tasks that depend on these refined security events include the verification of compliance in regard to the integrity of network separation (network slicing) or content of PDU flows and the assessment of the impact of identified vulnerabilities, configuration drift, or malfunctions that result in degraded availability or integrity of data. Creating security events of high refinement from an staggering amount of (security) events of low refinement is the objective of the solution proposed in this document. This document defines and illustrates five core elements that are required to facilitate a refinement process that conducts aggregation, correlation and analysis of event streams with machine learning and AI procedures in a distributed mash of virtual (and sometimes also hardware-bound) functions:</t>

<t><list style="symbols">
  <t>an information sharing architecture that is feasible to be applied in the thing-2-thing scope, including a pub/sub approach virtual functions that are bundled in SERF components can exchange information with</t>
  <t>an information model that defines the basic set of information elements providing the features required for machine-learning functions and AI procedures to create output of higher refinement in order to satisfy common security requirements via automation procedures</t>
  <t>a concise data model for security events that can be interpreted and processed by SERF components to fuel correpsonding machine-learning functions and AI procedures</t>
  <t>two alternative architecture designs based on CoAP pub/sub interaction model and based on SSLS peer-2-peer topics that are brokered via a resource directory</t>
  <t>integration of content authorization into existing and emerging building-blocks that compose a SERF domain, leveraging solutions developed in the ACE work group</t>
</list></t>

<t>The architectures defined in this document provide the capability to bundle machine-learning and AI procedures in SERF components in the form of virtual functions. Hence, SERF components can be migrated, spawned and discarded to support dynamic changes in regard to processing capability and scalability. The dynamic orchestration of the virtual functions that compose a SERF domain address the resilience and scalability required in the of malicious acts, such as DDoS attacks in production systems, targeted attacks at the SERF domain itself, or massive system failures that requires ad-hoc remediation. SERF components are able to attest their integrity using traditional remote attestation and emerging attestation procedures (such as TUDA). Heterogeneous sources of security events, such as proprietary anomaly detection components, netflow statistics, automobile ECU, actuators and sensors in ICS, or constrained-node networks in the thing-2-thing scope.</t>

<section anchor="requirements-notation" title="Requirements notation">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”,
“SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and
“OPTIONAL” in this document are to be interpreted as described in RFC
2119, BCP 14 <xref target="RFC2119"/>.</t>

</section>
</section>
<section anchor="section-1" title="Section 1">

<t>The meat goes here.</t>

<t>The second paragraph is here</t>

<t><list style="hanging">
  <t hangText='This is:'>
  a defintion</t>
</list></t>

<figure><artwork><![CDATA[
This
is
a
listing

]]></artwork></figure>

</section>
<section anchor="section-2" title="Section 2">

<t>Some more meat here.</t>

</section>
<section anchor="iana-considerations" title="IANA considerations">

<t>This document will include requests to IANA:</t>

<t><list style="symbols">
  <t>first item</t>
  <t>second item</t>
</list></t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>There are always some.</t>

</section>
<section anchor="acknowledgements" title="Acknowledgements">

<t>Maybe.</t>

</section>
<section anchor="change-log" title="Change Log">

<t>No changes yet.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor='RFC2119' target='http://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>




    </references>




  </back>
</rfc>

